#!/bin/sh

set -x

# hardcoded in gvisor-tap-vsock
VPNKIT_GATEWAY_IP="192.168.127.1"
VPNKIT_HOST_IP="192.168.127.254"

# overrideable with env
GVPROXY_PATH=${GVPROXY_PATH:-/app/wsl-gvproxy.exe}
TAP_NAME=${TAP_NAME:-wsltap}
CHECK_HOST=${CHECK_HOST:-example.com}
CHECK_DNS=${CHECK_DNS:-1.1.1.1}
DEBUG=${DEBUG:-0}

set +x

# WSL2 default values
WSL2_TAP_NAME="eth0"
RESOLV_CONF="/etc/resolv.conf"
WSL2_GATEWAY_IP="$(cat $RESOLV_CONF | awk '/^nameserver/ {print $2}')"

set -x

# show values
WSL2_TAP_NAME=$WSL2_TAP_NAME
WSL2_GATEWAY_IP=$WSL2_GATEWAY_IP

if [ "$DEBUG" -eq 0 ]; then
    set +x
fi

# script vars
VM_PID=
RESOLV_VALUE="$(cat $RESOLV_CONF)"

# replace calls to iptables if iptables-legacy exists
command -v iptables-legacy && alias iptables=iptables-legacy

run () {
    wsl2tap_down

    echo "starting gvproxy at $GVPROXY_PATH..."
    wsl-vm \
        -url="stdio:$GVPROXY_PATH?listen-stdio=accept&debug=$DEBUG" \
        -iface="$TAP_NAME" \
        -stop-if-exist="$TAP_NAME" \
        -debug=$DEBUG &
    VM_PID=$!
    echo "started gvproxy"
}

dhcp_wait () {
    echo "waiting for dhcp..."
    c=1
    d=0
    while [ "$c" -eq 1 ] && [ "$d" -eq 0 ]; do
        sleep 0.1
        ip route show dev $TAP_NAME | grep $VPNKIT_GATEWAY_IP
        c=$?
        kill -0 $VM_PID
        d=$?
    done

    resolv_restore

    if [ "$d" -eq 1 ]; then
        echo "wsl-vm exited"
        exit 1
    fi
    echo "dhcp completed"
}

wsl2tap_down () {
    # take down WSL2 tap so DHCP will set default route
    ip link set dev $WSL2_TAP_NAME down
}

wsl2tap_up () {
    # bring up WSL2 tap
    ip link set dev $WSL2_TAP_NAME up

    # restore WSL2 default route
    ip route add default via $WSL2_GATEWAY_IP dev $WSL2_TAP_NAME
}

resolv_restore () {
    # restore resolv.conf after DHCP
    echo "$RESOLV_VALUE" > /etc/resolv.conf
}

iptables_set () {
    iptables -t nat -$1 PREROUTING -d $WSL2_GATEWAY_IP/32 -p udp -m udp --dport 53 -j DNAT --to-destination $VPNKIT_GATEWAY_IP:53
    iptables -t nat -$1 PREROUTING -d $WSL2_GATEWAY_IP/32 -p tcp -m tcp --dport 53 -j DNAT --to-destination $VPNKIT_GATEWAY_IP:53
    iptables -t nat -$1 PREROUTING -d $WSL2_GATEWAY_IP/32 -j DNAT --to-destination $VPNKIT_HOST_IP
    iptables -t nat -$1 OUTPUT -d $WSL2_GATEWAY_IP/32 -p udp -m udp --dport 53 -j DNAT --to-destination $VPNKIT_GATEWAY_IP:53
    iptables -t nat -$1 OUTPUT -d $WSL2_GATEWAY_IP/32 -p tcp -m tcp --dport 53 -j DNAT --to-destination $VPNKIT_GATEWAY_IP:53
    iptables -t nat -$1 OUTPUT -d $WSL2_GATEWAY_IP/32 -j DNAT --to-destination $VPNKIT_HOST_IP
    iptables -t nat -$1 POSTROUTING -o $TAP_NAME -j MASQUERADE
}

check_ping () {
    ping -$1 -c 1 $3 >/dev/null && \
        echo "check: ✔️ ping success to IPv$1 $2 ($3)" || \
        echo "check: $([ $1 = '6' ] && echo '➖' || echo '❌') ping fail to IPv$1 $2 ($3)"
}

check_dns () {
    TYPE=$([ "$1" = "4" ] && echo 'A' || echo 'AAAA')
    nslookup -type=$TYPE $2 $3 >/dev/null && \
        echo "check: ✔️ nslookup success for $2 $TYPE using $3" || \
        echo "check: ❌ nslookup fail for $2 $TYPE using $3"
}

check_https () {
    wget --spider -q $1 && \
        echo "check: ✔️ wget success for $1" || \
        echo "check: ❌ wget fail for $1"
}

check () {
    check_ping 4 'WSL 2 gateway / Windows host' $WSL2_GATEWAY_IP
    check_ping 4 'Windows host' $VPNKIT_HOST_IP
    check_ping 4 'gateway' $VPNKIT_GATEWAY_IP
    check_dns 4 $CHECK_HOST $VPNKIT_GATEWAY_IP
    check_dns 4 $CHECK_HOST $WSL2_GATEWAY_IP
    check_dns 4 $CHECK_HOST $CHECK_DNS
    check_ping 4 'external host domain' $CHECK_HOST
    check_ping 4 'external host IP' $CHECK_DNS
    check_dns 6 $CHECK_HOST $VPNKIT_GATEWAY_IP
    check_dns 6 $CHECK_HOST $WSL2_GATEWAY_IP
    check_dns 6 $CHECK_HOST $CHECK_DNS
    check_ping 6 'external host' $CHECK_HOST
    check_https "https://$CHECK_HOST"
}

cleanup () {
    iptables_set D
    wsl2tap_up
    resolv_restore
}

close () {
    echo "cleaning up..."
    cleanup
    echo "stopped wsl-vpnkit"
    kill 0
}

if [ ${EUID:-$(id -u)} -ne 0 ]; then
    echo "Please run this script as root"
    exit 1
fi

# trap first so close runs even if the rest of the commands fail
trap close exit
trap exit int term

# run cleanup to restore any leftover configuration changes
cleanup

run
dhcp_wait
iptables_set A
check
wait
